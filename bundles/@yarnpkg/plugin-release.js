/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-release",
factory: function (require) {
var plugin;(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{default:()=>u});function r(e,t,r,n){var o,s=arguments.length,a=s<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,r,n);else for(var i=e.length-1;i>=0;i--)(o=e[i])&&(a=(s<3?o(a):s>3?o(t,r,a):o(t,r))||a);return s>3&&a&&Object.defineProperty(t,r,a),a}Object.create;Object.create;const n=require("@yarnpkg/core"),o=require("clipanion"),s=require("fs"),a=require("@yarnpkg/fslib"),i=require("@yarnpkg/parsers");require("semver");var c;async function l(e,{allowEmpty:t=!1}={}){const r=e.configuration;if(null===r.projectCwd)throw new o.UsageError("This command can only be run from within a Yarn project");const s=await async function(e){let t,r=null,n=e;do{t=n,await a.xfs.existsPromise(a.ppath.join(t,".git"))&&(r=t),n=a.ppath.dirname(t)}while(null===r&&n!==t);return r}(r.projectCwd),l=null!==s?await async function(e,{baseRefs:t}){if(0===t.length)throw new o.UsageError("Can't run this command with zero base refs specified.");const r=[];for(const o of t){const{code:t}=await n.execUtils.execvp("git",["merge-base",o,"HEAD"],{cwd:e});0===t&&r.push(o)}if(0===r.length)throw new o.UsageError("No ancestor could be found between any of HEAD and "+t.join(", "));const{stdout:s}=await n.execUtils.execvp("git",["merge-base","HEAD",...r],{cwd:e,strict:!0}),a=s.trim(),{stdout:i}=await n.execUtils.execvp("git",["show","--quiet","--pretty=format:%s",a],{cwd:e,strict:!0});return{hash:a,title:i.trim()}}(s,{baseRefs:r.get("changesetBaseRefs")}):null,p=null!==s?await async function(e,{base:t,project:r}){const o=n.miscUtils.buildIgnorePattern(r.configuration.get("changesetIgnorePatterns")),{stdout:s}=await n.execUtils.execvp("git",["diff","--name-only",""+t],{cwd:e,strict:!0}),i=s.split(/\r\n|\r|\n/).filter(e=>e.length>0).map(t=>a.ppath.resolve(e,a.npath.toPortablePath(t))),{stdout:c}=await n.execUtils.execvp("git",["ls-files","--others","--exclude-standard"],{cwd:e,strict:!0}),l=c.split(/\r\n|\r|\n/).filter(e=>e.length>0).map(t=>a.ppath.resolve(e,a.npath.toPortablePath(t))),p=[...new Set([...i,...l].sort())];return o?p.filter(e=>!a.ppath.relative(r.cwd,e).match(o)):p}(s,{base:l.hash,project:e}):[],d=r.get("deferredVersionFolder"),u=p.filter(e=>null!==a.ppath.contains(d,e));if(u.length>1)throw new o.UsageError("Your current branch contains multiple versioning files; this isn't supported:\n- "+u.join("\n- "));const h=new Set(n.miscUtils.mapAndFilter(p,t=>{const r=e.tryWorkspaceByFilePath(t);return null===r?n.miscUtils.mapAndFilter.skip:r}));if(0===u.length&&0===h.size&&!t)return null;const f=1===u.length?u[0]:a.ppath.join(d,n.hashUtils.makeHash(Math.random().toString()).slice(0,8)+".yml"),g=a.xfs.existsSync(f)?await a.xfs.readFilePromise(f,"utf8"):"{}",m=(0,i.parseSyml)(g),w=new Map;for(const t of m.declined||[]){const r=n.structUtils.parseIdent(t),o=e.getWorkspaceByIdent(r);w.set(o,c.DECLINE)}for(const[t,r]of Object.entries(m.releases||{})){const o=n.structUtils.parseIdent(t),s=e.getWorkspaceByIdent(o);w.set(s,r)}return{project:e,root:s,baseHash:null!==l?l.hash:null,baseTitle:null!==l?l.title:null,changedFiles:new Set(p),changedWorkspaces:h,releaseRoots:new Set([...h].filter(e=>null!==e.manifest.version)),releases:w,async saveAll(){const t={},r=[],o=[];for(const s of e.workspaces){if(null===s.manifest.version)continue;const e=n.structUtils.stringifyIdent(s.locator),a=w.get(s);a===c.DECLINE?r.push(e):void 0!==a?t[e]=a:h.has(s)&&o.push(e)}await a.xfs.mkdirPromise(a.ppath.dirname(f),{recursive:!0}),await a.xfs.changeFilePromise(f,(0,i.stringifySyml)(new i.stringifySyml.PreserveOrdering({releases:Object.keys(t).length>0?t:void 0,declined:r.length>0?r:void 0,undecided:o.length>0?o:void 0})))}}}!function(e){e.UNDECIDED="undecided",e.DECLINE="decline",e.MAJOR="major",e.MINOR="minor",e.PATCH="patch",e.PRERELEASE="prerelease"}(c||(c={}));class p{async generateReport(e,t=!1){const r=await l(e);if(!r)throw new Error("No any relevant information about the project");return function(e,t=!1){const{changedFiles:r,changedWorkspaces:n,root:o}=e;console.dir([...e.changedWorkspaces][1].manifest);const s={generatedAt:Date.now(),root:o,changedWorkspaces:[...n].filter(({cwd:e})=>!t||e!==o).map(({locator:e,cwd:t,relativeCwd:r})=>({name:e.name,scope:e.scope,path:t,relativePath:r,currentVersion:e.reference,changedFiles:[]})).sort((e,t)=>e.path.length>=t.path.length?-1:1)};return r.forEach(e=>{const t=s.changedWorkspaces.find(({path:t})=>e.includes(t));t&&t.changedFiles.push(e)}),s}(r,t)}}class d extends o.Command{constructor(){super(...arguments),this.ignoreRoot=!1,this.saveReport=!1,this.reportManager=new p}async execute(){const e=await n.Configuration.find(this.context.cwd,this.context.plugins),{project:t}=await n.Project.find(e,this.context.cwd),r=await this.reportManager.generateReport(t,this.ignoreRoot);this.outputReport(r)}outputReport(e){const t=JSON.stringify(e);this.saveReport?(0,s.writeFileSync)("./report.json",t,"utf-8"):console.dir(t)}}d.usage=o.Command.Usage({category:"Release commands",description:"Generate json report about release candidates"}),r([o.Command.Boolean("--ignore-root",{description:"Ignore the root workspace"})],d.prototype,"ignoreRoot",void 0),r([o.Command.Boolean("--save-report",{description:"Save JSON at your filesystem otherwise the result will be printed at your terminal."})],d.prototype,"saveReport",void 0),r([o.Command.Path("release","report")],d.prototype,"execute",null);const u={commands:[d]};plugin=t})();
return plugin;
}
};