/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-release",
factory: function (require) {
var plugin;(()=>{var e={269:function(e){e.exports=function(){function e(t,r,n,o,a,s,i){var c,l,p="",d=0,h=o.slice(0);if(h.push([r,n])&&o.length>0&&(o.forEach((function(e,t){t>0&&(p+=(e[1]?" ":"│")+"  "),l||e[0]!==r||(l=!0)})),p+=function(e,t){var r=t?"└":"├";return r+=e?"─ ":"──┐"}(t,n)+t,a&&("object"!=typeof r||r instanceof Date)&&(p+=": "+r),l&&(p+=" (circular ref.)"),i(p)),!l&&"object"==typeof r){var u=function(e,t){var r=[];for(var n in e)e.hasOwnProperty(n)&&(t&&"function"==typeof e[n]||r.push(n));return r}(r,s);u.forEach((function(t){c=++d===u.length,e(t,r[t],c,h,a,s,i)}))}}var t={asLines:function(t,r,n,o){e(".",t,!1,[],r,"function"!=typeof n&&n,o||n)},asTree:function(t,r,n){var o="";return e(".",t,!1,[],r,n,(function(e){o+=e+"\n"})),o}};return t}()}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var a=t[n]={exports:{}};return e[n].call(a.exports,a,a.exports,r),a.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};(()=>{"use strict";r.r(n),r.d(n,{default:()=>y});function e(e,t,r,n){var o,a=arguments.length,s=a<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,n);else for(var i=e.length-1;i>=0;i--)(o=e[i])&&(s=(a<3?o(s):a>3?o(t,r,s):o(t,r))||s);return a>3&&s&&Object.defineProperty(t,r,s),s}Object.create;Object.create;const t=require("@yarnpkg/core"),o=require("clipanion");var a,s=r(269);!function(e){e.json="json",e.tree="tree"}(a||(a={}));class i{constructor(e,t){this.workspace=e,this.root=t,this.children=new Map,this.chain=new Set,this.chain=new Set(this.root?this.root.chain:void 0),this.chain.add(e.anchoredLocator.identHash)}get id(){return this.workspace.anchoredLocator.identHash}get name(){return this.workspace.manifest.raw.name}addChildren(e){return this.children.set(e.id,e),this}}class c{async buildGraph(e){await e.restoreInstallState();const t=this.getEssentialWorkspaces(e);if(0===t.length)throw new Error("Project doesn't have any essentail workspaces");const r=new i(e.topLevelWorkspace);return t.forEach(t=>{const n=new i(t,r);this.fillChildrenNodes(e,n),r.addChildren(n)}),r}getWorkspacePackage(e,t){const r=e.storedPackages.get(t.anchoredLocator.locatorHash);if(!r)throw new Error("Unknown workspace");return r}getEssentialWorkspaces(e){return e.workspaces.filter(t=>t.locator.name!==e.topLevelWorkspace.locator.name&&0===this.getWorkspaceInternalDependencies(e,t).size)}getWorkspaceInternalDependencies(e,t){const r=this.getWorkspacePackage(e,t),n=new Set;return[...r.dependencies,...r.peerDependencies].forEach(([,t])=>{const r=e.tryWorkspaceByIdent(t);r&&n.add(r)}),n}getWorkspaceExternalDependencies(e,t){const r=e.workspaces.filter(r=>{const n=this.getWorkspacePackage(e,r);return n.dependencies.has(t.locator.identHash)||n.peerDependencies.has(t.locator.identHash)});return new Set(r)}fillChildrenNodes(e,t){this.getWorkspaceExternalDependencies(e,t.workspace).forEach(r=>{if(t.chain.has(r.anchoredLocator.identHash))return;const n=new i(r,t);t.addChildren(n),this.fillChildrenNodes(e,n)})}}function l(e){const t=e.children.size>0?{}:null;return e.children.forEach(e=>{t[e.name]=l(e)}),t}class p extends o.Command{constructor(){super(...arguments),this.outputFormat=a.tree,this.graphManager=new c}async execute(){this.validateInput();const e=await t.Configuration.find(this.context.cwd,this.context.plugins),{project:r}=await t.Project.find(e,this.context.cwd),n=await this.graphManager.buildGraph(r);console.log(this.formattedOutputTree(n))}validateInput(){if(!Object.keys(a).includes(this.outputFormat))throw new o.UsageError("Invalid --output-format option, can be 'json', 'tree'")}formattedOutputTree(e){switch(this.outputFormat){case a.json:return JSON.stringify(function e(t){const r=[];return t.children.forEach(t=>{r.push(e(t))}),{name:t.name,children:r}}(e));case a.tree:return(0,s.asTree)(function(e){return{[e.name]:l(e)}}(e),!1,!0);default:return""}}}p.usage=o.Command.Usage({category:"Release commands",description:"Prints monitored workspaces graph"}),e([o.Command.String("-o,--output-format",{description:"Output format, can be 'json', 'tree'"})],p.prototype,"outputFormat",void 0),e([o.Command.Path("release","graph")],p.prototype,"execute",null);const d=require("fs"),h=require("@yarnpkg/fslib"),u=require("@yarnpkg/parsers");require("semver");var f;async function g(e,{allowEmpty:r=!1}={}){const n=e.configuration;if(null===n.projectCwd)throw new o.UsageError("This command can only be run from within a Yarn project");const a=await async function(e){let t,r=null,n=e;do{t=n,await h.xfs.existsPromise(h.ppath.join(t,".git"))&&(r=t),n=h.ppath.dirname(t)}while(null===r&&n!==t);return r}(n.projectCwd),s=null!==a?await async function(e,{baseRefs:r}){if(0===r.length)throw new o.UsageError("Can't run this command with zero base refs specified.");const n=[];for(const o of r){const{code:r}=await t.execUtils.execvp("git",["merge-base",o,"HEAD"],{cwd:e});0===r&&n.push(o)}if(0===n.length)throw new o.UsageError("No ancestor could be found between any of HEAD and "+r.join(", "));const{stdout:a}=await t.execUtils.execvp("git",["merge-base","HEAD",...n],{cwd:e,strict:!0}),s=a.trim(),{stdout:i}=await t.execUtils.execvp("git",["show","--quiet","--pretty=format:%s",s],{cwd:e,strict:!0});return{hash:s,title:i.trim()}}(a,{baseRefs:n.get("changesetBaseRefs")}):null,i=null!==a?await async function(e,{base:r,project:n}){const o=t.miscUtils.buildIgnorePattern(n.configuration.get("changesetIgnorePatterns")),{stdout:a}=await t.execUtils.execvp("git",["diff","--name-only",""+r],{cwd:e,strict:!0}),s=a.split(/\r\n|\r|\n/).filter(e=>e.length>0).map(t=>h.ppath.resolve(e,h.npath.toPortablePath(t))),{stdout:i}=await t.execUtils.execvp("git",["ls-files","--others","--exclude-standard"],{cwd:e,strict:!0}),c=i.split(/\r\n|\r|\n/).filter(e=>e.length>0).map(t=>h.ppath.resolve(e,h.npath.toPortablePath(t))),l=[...new Set([...s,...c].sort())];return o?l.filter(e=>!h.ppath.relative(n.cwd,e).match(o)):l}(a,{base:s.hash,project:e}):[],c=n.get("deferredVersionFolder"),l=i.filter(e=>null!==h.ppath.contains(c,e));if(l.length>1)throw new o.UsageError("Your current branch contains multiple versioning files; this isn't supported:\n- "+l.join("\n- "));const p=new Set(t.miscUtils.mapAndFilter(i,r=>{const n=e.tryWorkspaceByFilePath(r);return null===n?t.miscUtils.mapAndFilter.skip:n}));if(0===l.length&&0===p.size&&!r)return null;const d=1===l.length?l[0]:h.ppath.join(c,t.hashUtils.makeHash(Math.random().toString()).slice(0,8)+".yml"),g=h.xfs.existsSync(d)?await h.xfs.readFilePromise(d,"utf8"):"{}",m=(0,u.parseSyml)(g),w=new Map;for(const r of m.declined||[]){const n=t.structUtils.parseIdent(r),o=e.getWorkspaceByIdent(n);w.set(o,f.DECLINE)}for(const[r,n]of Object.entries(m.releases||{})){const o=t.structUtils.parseIdent(r),a=e.getWorkspaceByIdent(o);w.set(a,n)}return{project:e,root:a,baseHash:null!==s?s.hash:null,baseTitle:null!==s?s.title:null,changedFiles:new Set(i),changedWorkspaces:p,releaseRoots:new Set([...p].filter(e=>null!==e.manifest.version)),releases:w,async saveAll(){const r={},n=[],o=[];for(const a of e.workspaces){if(null===a.manifest.version)continue;const e=t.structUtils.stringifyIdent(a.locator),s=w.get(a);s===f.DECLINE?n.push(e):void 0!==s?r[e]=s:p.has(a)&&o.push(e)}await h.xfs.mkdirPromise(h.ppath.dirname(d),{recursive:!0}),await h.xfs.changeFilePromise(d,(0,u.stringifySyml)(new u.stringifySyml.PreserveOrdering({releases:Object.keys(r).length>0?r:void 0,declined:n.length>0?n:void 0,undecided:o.length>0?o:void 0})))}}}!function(e){e.UNDECIDED="undecided",e.DECLINE="decline",e.MAJOR="major",e.MINOR="minor",e.PATCH="patch",e.PRERELEASE="prerelease"}(f||(f={}));class m{async generateReport(e,t){const{ignoreRoot:r=!1}=t||{},n=await g(e);if(!n)throw new Error("No any relevant information about the project");return function(e,t=[]){const{changedFiles:r,changedWorkspaces:n,root:o}=e,a={generatedAt:Date.now(),root:o,changedWorkspaces:[...n].filter(({locator:e})=>!t.includes(e.locatorHash)).map(({locator:e,cwd:t,relativeCwd:r,manifest:n})=>({fullName:n.raw.name||e.name,name:e.name,scope:e.scope,locatorHash:e.locatorHash,path:t,relativePath:r,currentVersion:e.reference,changedFiles:[],dependencies:n.dependencies}))},s=a.changedWorkspaces.sort((e,t)=>e.path.length>=t.path.length?-1:1);return r.forEach(e=>{const t=s.find(({path:t})=>e.includes(t));t&&t.changedFiles.push(e)}),a}(n,r?[e.topLevelWorkspace.locator.locatorHash]:[])}}class w extends o.Command{constructor(){super(...arguments),this.ignoreRoot=!1,this.saveReport=!1,this.topological=!0,this.reportManager=new m}async execute(){const e=await t.Configuration.find(this.context.cwd,this.context.plugins),{project:r}=await t.Project.find(e,this.context.cwd),n=await this.reportManager.generateReport(r,{ignoreRoot:this.ignoreRoot,topological:this.topological});this.outputReport(n)}outputReport(e){const t=JSON.stringify(e);this.saveReport?(0,d.writeFileSync)("./report.json",t,"utf-8"):console.dir(t)}}w.usage=o.Command.Usage({category:"Release commands",description:"Generate json report about release candidates"}),e([o.Command.Boolean("--ignore-root",{description:"Ignore the root workspace"})],w.prototype,"ignoreRoot",void 0),e([o.Command.Boolean("--save-report",{description:"Save JSON at your filesystem otherwise the result will be printed at your terminal."})],w.prototype,"saveReport",void 0),e([o.Command.Boolean("-t,--topological",{description:"Preserve topological ordering."})],w.prototype,"topological",void 0),e([o.Command.Path("release","report")],w.prototype,"execute",null);const y={commands:[w,p]}})(),plugin=n})();
return plugin;
}
};