/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-release",
factory: function (require) {
var plugin;(()=>{var e={269:function(e){e.exports=function(){function e(t,r,o,n,s,a,i){var c,l,p="",u=0,d=n.slice(0);if(d.push([r,o])&&n.length>0&&(n.forEach((function(e,t){t>0&&(p+=(e[1]?" ":"│")+"  "),l||e[0]!==r||(l=!0)})),p+=function(e,t){var r=t?"└":"├";return r+=e?"─ ":"──┐"}(t,o)+t,s&&("object"!=typeof r||r instanceof Date)&&(p+=": "+r),l&&(p+=" (circular ref.)"),i(p)),!l&&"object"==typeof r){var h=function(e,t){var r=[];for(var o in e)e.hasOwnProperty(o)&&(t&&"function"==typeof e[o]||r.push(o));return r}(r,a);h.forEach((function(t){c=++u===h.length,e(t,r[t],c,d,s,a,i)}))}}var t={asLines:function(t,r,o,n){e(".",t,!1,[],r,"function"!=typeof o&&o,n||o)},asTree:function(t,r,o){var n="";return e(".",t,!1,[],r,o,(function(e){n+=e+"\n"})),n}};return t}()}},t={};function r(o){var n=t[o];if(void 0!==n)return n.exports;var s=t[o]={exports:{}};return e[o].call(s.exports,s,s.exports,r),s.exports}r.d=(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};(()=>{"use strict";r.r(o),r.d(o,{default:()=>y});function e(e,t,r,o){var n,s=arguments.length,a=s<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,r,o);else for(var i=e.length-1;i>=0;i--)(n=e[i])&&(a=(s<3?n(a):s>3?n(t,r,a):n(t,r))||a);return s>3&&a&&Object.defineProperty(t,r,a),a}Object.create;Object.create;const t=require("@yarnpkg/core"),n=require("clipanion"),s=require("fs"),a=require("@yarnpkg/fslib"),i=require("@yarnpkg/parsers");require("semver");var c;async function l(e,{allowEmpty:r=!1}={}){const o=e.configuration;if(null===o.projectCwd)throw new n.UsageError("This command can only be run from within a Yarn project");const s=await async function(e){let t,r=null,o=e;do{t=o,await a.xfs.existsPromise(a.ppath.join(t,".git"))&&(r=t),o=a.ppath.dirname(t)}while(null===r&&o!==t);return r}(o.projectCwd),l=null!==s?await async function(e,{baseRefs:r}){if(0===r.length)throw new n.UsageError("Can't run this command with zero base refs specified.");const o=[];for(const n of r){const{code:r}=await t.execUtils.execvp("git",["merge-base",n,"HEAD"],{cwd:e});0===r&&o.push(n)}if(0===o.length)throw new n.UsageError("No ancestor could be found between any of HEAD and "+r.join(", "));const{stdout:s}=await t.execUtils.execvp("git",["merge-base","HEAD",...o],{cwd:e,strict:!0}),a=s.trim(),{stdout:i}=await t.execUtils.execvp("git",["show","--quiet","--pretty=format:%s",a],{cwd:e,strict:!0});return{hash:a,title:i.trim()}}(s,{baseRefs:o.get("changesetBaseRefs")}):null,p=null!==s?await async function(e,{base:r,project:o}){const n=t.miscUtils.buildIgnorePattern(o.configuration.get("changesetIgnorePatterns")),{stdout:s}=await t.execUtils.execvp("git",["diff","--name-only",""+r],{cwd:e,strict:!0}),i=s.split(/\r\n|\r|\n/).filter(e=>e.length>0).map(t=>a.ppath.resolve(e,a.npath.toPortablePath(t))),{stdout:c}=await t.execUtils.execvp("git",["ls-files","--others","--exclude-standard"],{cwd:e,strict:!0}),l=c.split(/\r\n|\r|\n/).filter(e=>e.length>0).map(t=>a.ppath.resolve(e,a.npath.toPortablePath(t))),p=[...new Set([...i,...l].sort())];return n?p.filter(e=>!a.ppath.relative(o.cwd,e).match(n)):p}(s,{base:l.hash,project:e}):[],u=o.get("deferredVersionFolder"),d=p.filter(e=>null!==a.ppath.contains(u,e));if(d.length>1)throw new n.UsageError("Your current branch contains multiple versioning files; this isn't supported:\n- "+d.join("\n- "));const h=new Set(t.miscUtils.mapAndFilter(p,r=>{const o=e.tryWorkspaceByFilePath(r);return null===o?t.miscUtils.mapAndFilter.skip:o}));if(0===d.length&&0===h.size&&!r)return null;const f=1===d.length?d[0]:a.ppath.join(u,t.hashUtils.makeHash(Math.random().toString()).slice(0,8)+".yml"),g=a.xfs.existsSync(f)?await a.xfs.readFilePromise(f,"utf8"):"{}",m=(0,i.parseSyml)(g),w=new Map;for(const r of m.declined||[]){const o=t.structUtils.parseIdent(r),n=e.getWorkspaceByIdent(o);w.set(n,c.DECLINE)}for(const[r,o]of Object.entries(m.releases||{})){const n=t.structUtils.parseIdent(r),s=e.getWorkspaceByIdent(n);w.set(s,o)}return{project:e,root:s,baseHash:null!==l?l.hash:null,baseTitle:null!==l?l.title:null,changedFiles:new Set(p),changedWorkspaces:h,releaseRoots:new Set([...h].filter(e=>null!==e.manifest.version)),releases:w,async saveAll(){const r={},o=[],n=[];for(const s of e.workspaces){if(null===s.manifest.version)continue;const e=t.structUtils.stringifyIdent(s.locator),a=w.get(s);a===c.DECLINE?o.push(e):void 0!==a?r[e]=a:h.has(s)&&n.push(e)}await a.xfs.mkdirPromise(a.ppath.dirname(f),{recursive:!0}),await a.xfs.changeFilePromise(f,(0,i.stringifySyml)(new i.stringifySyml.PreserveOrdering({releases:Object.keys(r).length>0?r:void 0,declined:o.length>0?o:void 0,undecided:n.length>0?n:void 0})))}}}!function(e){e.UNDECIDED="undecided",e.DECLINE="decline",e.MAJOR="major",e.MINOR="minor",e.PATCH="patch",e.PRERELEASE="prerelease"}(c||(c={}));class p{async generateReport(e,t){const{ignoreRoot:r=!1,topological:o=!0}=t||{},n=await l(e);if(!n)throw new Error("No any relevant information about the project");return function(e,t=!1){const{changedFiles:r,changedWorkspaces:o,root:n}=e,s={generatedAt:Date.now(),root:n,changedWorkspaces:[...o].filter(({cwd:e})=>!t||e!==n).map(({locator:e,cwd:t,relativeCwd:r,manifest:o})=>({fullName:o.raw.name||e.name,name:e.name,scope:e.scope,path:t,relativePath:r,currentVersion:e.reference,changedFiles:[],dependencies:o.dependencies})).sort((e,t)=>e.path.length>=t.path.length?-1:1)};return r.forEach(e=>{const t=s.changedWorkspaces.find(({path:t})=>e.includes(t));t&&t.changedFiles.push(e)}),s}(n,r)}}class u extends n.Command{constructor(){super(...arguments),this.ignoreRoot=!1,this.saveReport=!1,this.topological=!0,this.reportManager=new p}async execute(){const e=await t.Configuration.find(this.context.cwd,this.context.plugins),{project:r}=await t.Project.find(e,this.context.cwd),o=await this.reportManager.generateReport(r,{ignoreRoot:this.ignoreRoot,topological:this.topological});this.outputReport(o)}outputReport(e){const t=JSON.stringify(e);this.saveReport?(0,s.writeFileSync)("./report.json",t,"utf-8"):console.dir(t)}}u.usage=n.Command.Usage({category:"Release commands",description:"Generate json report about release candidates"}),e([n.Command.Boolean("--ignore-root",{description:"Ignore the root workspace"})],u.prototype,"ignoreRoot",void 0),e([n.Command.Boolean("--save-report",{description:"Save JSON at your filesystem otherwise the result will be printed at your terminal."})],u.prototype,"saveReport",void 0),e([n.Command.Boolean("-t,--topological",{description:"Preserve topological ordering."})],u.prototype,"topological",void 0),e([n.Command.Path("release","report")],u.prototype,"execute",null);var d,h=r(269);class f{constructor(e,t=new Set){this.workspace=e,this.children=new Set,this.history=new Set,this.history=new Set(t),this.history.add(e.locator.locatorHash)}get name(){return this.workspace.manifest.raw.name}forJSON(){return{name:this.name,children:[...this.children].map(e=>e.forJSON())}}}class g{async buildTree(e){await e.restoreInstallState();const t=this.getEssentialWorkspaces(e);if(0===t.length)throw new Error("Project doesn't have any essentail workspaces");const r=t.map(t=>{const r=new f(t);return this.fillChildrenNodes(e,r),r}),o=new f(e.topLevelWorkspace);return o.children=new Set(r),o}getWorkspacePackage(e,t){const r=e.storedPackages.get(t.anchoredLocator.locatorHash);if(!r)throw new Error("Unknown workspace");return r}getEssentialWorkspaces(e){return e.workspaces.filter(t=>t.locator.name!==e.topLevelWorkspace.locator.name&&0===this.getWorkspaceInternalDependencies(e,t).size)}getWorkspaceInternalDependencies(e,t){const r=this.getWorkspacePackage(e,t),o=new Set;return[...r.dependencies,...r.peerDependencies].forEach(([t,r])=>{const n=e.tryWorkspaceByIdent(r);n&&o.add(n)}),o}getWorkspaceExternalDependencies(e,t){const r=e.workspaces.filter(r=>{const o=this.getWorkspacePackage(e,r);return o.dependencies.has(t.locator.identHash)||o.peerDependencies.has(t.locator.identHash)});return new Set(r)}fillChildrenNodes(e,t){const{workspace:r,history:o}=t;this.getWorkspaceExternalDependencies(e,r).forEach(r=>{const n=r.locator.locatorHash;if(o.has(n))return;const s=new f(r,o);t.children.add(s),this.fillChildrenNodes(e,s)})}}function m(e){if(0===e.children.size)return null;const t={};return e.children.forEach(e=>{t[e.name]=m(e)}),t}!function(e){e.json="json",e.tree="tree"}(d||(d={}));class w extends n.Command{constructor(){super(...arguments),this.outputFormat=d.tree,this.topologyManager=new g}async execute(){this.validateInput();const e=await t.Configuration.find(this.context.cwd,this.context.plugins),{project:r}=await t.Project.find(e,this.context.cwd),o=await this.topologyManager.buildTree(r);console.log(this.formattedOutputTree(o))}validateInput(){if(!Object.keys(d).includes(this.outputFormat))throw new n.UsageError("Invalid --output-format option, can be 'json', 'tree'")}formattedOutputTree(e){switch(this.outputFormat){case d.json:return JSON.stringify(e.forJSON());case d.tree:return(0,h.asTree)({[(t=e).name]:m(t)},!1,!0);default:return""}var t}}w.usage=n.Command.Usage({category:"Release commands",description:"Generate json topological tree"}),e([n.Command.String("-o,--output-format",{description:"Output format, can be 'json', 'tree'"})],w.prototype,"outputFormat",void 0),e([n.Command.Path("release","tree")],w.prototype,"execute",null);const y={commands:[u,w]}})(),plugin=o})();
return plugin;
}
};