/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-release",
factory: function (require) {
var plugin;(()=>{"use strict";var e={d:(t,r)=>{for(var o in r)e.o(r,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:r[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{default:()=>f});function r(e,t,r,o){var n,s=arguments.length,a=s<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,r,o);else for(var i=e.length-1;i>=0;i--)(n=e[i])&&(a=(s<3?n(a):s>3?n(t,r,a):n(t,r))||a);return s>3&&a&&Object.defineProperty(t,r,a),a}Object.create;Object.create;const o=require("@yarnpkg/core"),n=require("clipanion"),s=require("fs"),a=require("@yarnpkg/fslib"),i=require("@yarnpkg/parsers");require("semver");var c;async function l(e,{allowEmpty:t=!1}={}){const r=e.configuration;if(null===r.projectCwd)throw new n.UsageError("This command can only be run from within a Yarn project");const s=await async function(e){let t,r=null,o=e;do{t=o,await a.xfs.existsPromise(a.ppath.join(t,".git"))&&(r=t),o=a.ppath.dirname(t)}while(null===r&&o!==t);return r}(r.projectCwd),l=null!==s?await async function(e,{baseRefs:t}){if(0===t.length)throw new n.UsageError("Can't run this command with zero base refs specified.");const r=[];for(const n of t){const{code:t}=await o.execUtils.execvp("git",["merge-base",n,"HEAD"],{cwd:e});0===t&&r.push(n)}if(0===r.length)throw new n.UsageError("No ancestor could be found between any of HEAD and "+t.join(", "));const{stdout:s}=await o.execUtils.execvp("git",["merge-base","HEAD",...r],{cwd:e,strict:!0}),a=s.trim(),{stdout:i}=await o.execUtils.execvp("git",["show","--quiet","--pretty=format:%s",a],{cwd:e,strict:!0});return{hash:a,title:i.trim()}}(s,{baseRefs:r.get("changesetBaseRefs")}):null,p=null!==s?await async function(e,{base:t,project:r}){const n=o.miscUtils.buildIgnorePattern(r.configuration.get("changesetIgnorePatterns")),{stdout:s}=await o.execUtils.execvp("git",["diff","--name-only",""+t],{cwd:e,strict:!0}),i=s.split(/\r\n|\r|\n/).filter(e=>e.length>0).map(t=>a.ppath.resolve(e,a.npath.toPortablePath(t))),{stdout:c}=await o.execUtils.execvp("git",["ls-files","--others","--exclude-standard"],{cwd:e,strict:!0}),l=c.split(/\r\n|\r|\n/).filter(e=>e.length>0).map(t=>a.ppath.resolve(e,a.npath.toPortablePath(t))),p=[...new Set([...i,...l].sort())];return n?p.filter(e=>!a.ppath.relative(r.cwd,e).match(n)):p}(s,{base:l.hash,project:e}):[],d=r.get("deferredVersionFolder"),h=p.filter(e=>null!==a.ppath.contains(d,e));if(h.length>1)throw new n.UsageError("Your current branch contains multiple versioning files; this isn't supported:\n- "+h.join("\n- "));const u=new Set(o.miscUtils.mapAndFilter(p,t=>{const r=e.tryWorkspaceByFilePath(t);return null===r?o.miscUtils.mapAndFilter.skip:r}));if(0===h.length&&0===u.size&&!t)return null;const g=1===h.length?h[0]:a.ppath.join(d,o.hashUtils.makeHash(Math.random().toString()).slice(0,8)+".yml"),f=a.xfs.existsSync(g)?await a.xfs.readFilePromise(g,"utf8"):"{}",w=(0,i.parseSyml)(f),m=new Map;for(const t of w.declined||[]){const r=o.structUtils.parseIdent(t),n=e.getWorkspaceByIdent(r);m.set(n,c.DECLINE)}for(const[t,r]of Object.entries(w.releases||{})){const n=o.structUtils.parseIdent(t),s=e.getWorkspaceByIdent(n);m.set(s,r)}return{project:e,root:s,baseHash:null!==l?l.hash:null,baseTitle:null!==l?l.title:null,changedFiles:new Set(p),changedWorkspaces:u,releaseRoots:new Set([...u].filter(e=>null!==e.manifest.version)),releases:m,async saveAll(){const t={},r=[],n=[];for(const s of e.workspaces){if(null===s.manifest.version)continue;const e=o.structUtils.stringifyIdent(s.locator),a=m.get(s);a===c.DECLINE?r.push(e):void 0!==a?t[e]=a:u.has(s)&&n.push(e)}await a.xfs.mkdirPromise(a.ppath.dirname(g),{recursive:!0}),await a.xfs.changeFilePromise(g,(0,i.stringifySyml)(new i.stringifySyml.PreserveOrdering({releases:Object.keys(t).length>0?t:void 0,declined:r.length>0?r:void 0,undecided:n.length>0?n:void 0})))}}}!function(e){e.UNDECIDED="undecided",e.DECLINE="decline",e.MAJOR="major",e.MINOR="minor",e.PATCH="patch",e.PRERELEASE="prerelease"}(c||(c={}));class p{async generateReport(e,t){const{ignoreRoot:r=!1,topological:o=!0}=t||{},n=await l(e);if(!n)throw new Error("No any relevant information about the project");return function(e,t=!1){const{changedFiles:r,changedWorkspaces:o,root:n}=e,s={generatedAt:Date.now(),root:n,changedWorkspaces:[...o].filter(({cwd:e})=>!t||e!==n).map(({locator:e,cwd:t,relativeCwd:r,manifest:o})=>({fullName:o.raw.name||e.name,name:e.name,scope:e.scope,path:t,relativePath:r,currentVersion:e.reference,changedFiles:[],dependencies:o.dependencies})).sort((e,t)=>e.path.length>=t.path.length?-1:1)};return r.forEach(e=>{const t=s.changedWorkspaces.find(({path:t})=>e.includes(t));t&&t.changedFiles.push(e)}),s}(n,r)}}class d extends n.Command{constructor(){super(...arguments),this.ignoreRoot=!1,this.saveReport=!1,this.topological=!0,this.reportManager=new p}async execute(){const e=await o.Configuration.find(this.context.cwd,this.context.plugins),{project:t}=await o.Project.find(e,this.context.cwd),r=await this.reportManager.generateReport(t,{ignoreRoot:this.ignoreRoot,topological:this.topological});this.outputReport(r)}outputReport(e){const t=JSON.stringify(e);this.saveReport?(0,s.writeFileSync)("./report.json",t,"utf-8"):console.dir(t)}}d.usage=n.Command.Usage({category:"Release commands",description:"Generate json report about release candidates"}),r([n.Command.Boolean("--ignore-root",{description:"Ignore the root workspace"})],d.prototype,"ignoreRoot",void 0),r([n.Command.Boolean("--save-report",{description:"Save JSON at your filesystem otherwise the result will be printed at your terminal."})],d.prototype,"saveReport",void 0),r([n.Command.Boolean("-t,--topological",{description:"Preserve topological ordering."})],d.prototype,"topological",void 0),r([n.Command.Path("release","report")],d.prototype,"execute",null);class h{constructor(e,t=new Set){this.workspace=e,this.children=new Set,this.history=new Set,this.history=new Set(t),this.history.add(e.locator.locatorHash)}get name(){return this.workspace.manifest.raw.name}forJSON(){return{name:this.name,children:[...this.children].map(e=>e.forJSON())}}}class u{async buildTree(e){await e.restoreInstallState();const t=this.getEssentialWorkspaces(e);if(0===t.length)throw new Error("Project doesn't have any essentail workspaces");return t.map(t=>{const r=new h(t);return this.handleWorkspace(e,r),r})}getWorkspacePackage(e,t){const r=e.storedPackages.get(t.anchoredLocator.locatorHash);if(!r)throw new Error("Unknown workspace");return r}getEssentialWorkspaces(e){return e.workspaces.filter(t=>t.locator.name!==e.topLevelWorkspace.locator.name&&0===this.getWorkspaceInternalDependencies(e,t).size)}getWorkspaceInternalDependencies(e,t){const r=this.getWorkspacePackage(e,t),o=new Set;return[...r.dependencies,...r.peerDependencies].forEach(([t,r])=>{const n=e.tryWorkspaceByIdent(r);n&&o.add(n)}),o}getWorkspaceExternalDependencies(e,t){const r=e.workspaces.filter(r=>{const o=this.getWorkspacePackage(e,r);return o.dependencies.has(t.locator.identHash)||o.peerDependencies.has(t.locator.identHash)});return new Set(r)}handleWorkspace(e,t){const{workspace:r,history:o}=t;this.getWorkspaceExternalDependencies(e,r).forEach(r=>{const n=r.locator.locatorHash;if(o.has(n))return;const s=new h(r,o);t.children.add(s),this.handleWorkspace(e,s)})}}class g extends n.Command{constructor(){super(...arguments),this.topologyManager=new u}async execute(){const e=await o.Configuration.find(this.context.cwd,this.context.plugins),{project:t}=await o.Project.find(e,this.context.cwd),r=(await this.topologyManager.buildTree(t)).map(e=>e.forJSON());console.dir(JSON.stringify(r))}}g.usage=n.Command.Usage({category:"Release commands",description:"Generate json topological tree"}),r([n.Command.Path("release","tree")],g.prototype,"execute",null);const f={commands:[d,g]};plugin=t})();
return plugin;
}
};